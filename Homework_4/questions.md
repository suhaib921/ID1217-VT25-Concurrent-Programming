Problems:
1. A Fuel Space Station (40 points)
Consider a future fuel station in space that supplies nitrogen and quantum fluid. Assume that the station can handle V space vehicles in parallel (simultaneously) and maximum storage for N liters of nitrogen and Q liters of quantum fluid. When a vehicle arrives at the station, it requests the needed amounts of fuel of the two different types or only one of the types. If there is not enough fuel of either type, the vehicle has to wait without blocking other vehicles. Special supply vehicles deliver fuel in fixed quantities that far exceed the fuel tank capacity of any vehicle. When a supply vehicle arrives at the station, it delays until there is enough space to deposit the fuel delivered. To travel back, the supply vehicles also request a certain amount of fuel of the two different types or one of the types, just like an ordinary vehicle, not necessarily the type it supplies.

Develop and implement a multithreaded application (in Java or C++) that simulates the actions of the ordinary space vehicles and supply vehicles represented as concurrent threads. Your simulation program should implement all "real world" concurrency in the actions of the vehicles as described in the above scenario. Represent the fuel space station as a monitor (a synchronized object) containing a set of counters that define the amounts of available fuel of different types (at most  N liters of nitrogen and most Q liters of quantum fluid) and the number of free docking places (at most V places). The monitor should be used to control access to and station use. Develop and implement the monitor's methods. The vehicle threads call the monitor methods to request and release access to the station to get or/and deposit fuel. 

In your simulation program, assume that each vehicle arrives at the station periodically to get/supply fuel. Have the vehicles sleep (pause) for a random amount of time between arriving at the station to simulate the time it takes to travel in space, and have the vehicles sleep (pause) for a smaller random amount of time to simulate the time it takes to get/supply the fuel at the station. Stop the simulation after each vehicle has arrived at the station the given number of times. Your program should print a trace of the interesting events in the program.
Is your solution fair? Explain when presenting homework.

2. A Repair Station (40 points)
A vehicle repair station can repair vehicles of three types: A, B, and C. The station has the following capacity:

It can repair in parallel at most a, b, and c vehicles of type A, B, and C, correspondingly;
It can repair in parallel at most v vehicles of different types.
If a vehicle cannot be repaired because of any (or both) of the above limitations, the vehicle has to wait until it can get a place to be repaired.

(a) Develop a concurrent object class (a monitor with condition variables) that controls the station so that several vehicles can be repaired in parallel according to the station's capacity as described above. Define the monitor's operations and their implementation. Represent vehicles as processes and show how they can use the monitor. Is your solution fair? Explain (in comments in the source code).

Develop and implement a multithreaded application (in Java or C++) that simulates the actions of the vehicles represented as concurrent threads. Your simulation program should implement all "real world" concurrency in the actions of the vehicles as described in the above scenario. Represent the repair station as a monitor (a synchronized object) containing a set of counters that define available free places for vehicles of different types and the total number of available places. The monitor should control access to the repair station so that several vehicles can be repaired in parallel according to the station's capacity, as described above. Develop and implement the monitor's methods. The vehicle threads call the monitor methods to request and release access to the station to be repaired.

In your simulation program, assume that each vehicle arrives at the station periodically to get repaired. Have the vehicles sleep (pause) for a random amount of time between arriving at the station to simulate the time it takes to travel, and have the vehicles sleep (pause) for a smaller random amount of time to simulate the time it takes to be repaired at the station. Stop the simulation after each vehicle has arrived at the station the given number of times. Your program should print a trace of the interesting events in the program.
Is your solution fair? Explain when presenting homework.

3. The Dining Philosophers problem (20 points + 20 points for extra work)
Write a multithreaded program in Java or C++ to simulate the Dining Philosophers problem described in Lecture 10 (Semaphores), Slide 29. There should be at least five threads, one per philosopher, and one shared object (a monitor) for the table. The shared object (monitor) "table" should have two methods: getforks(id) and relforks(id), where id is an integer between 1 and 5. Your solution need not be fair.

Your program should have one command-line argument rounds that specifies the number of rounds of thinking and eating that each philosopher should execute. Philosophers should eat and think for random amounts of time. Your program may have additional command-line arguments, for example, to control the eating and thinking intervals and the seed for the random number generator. Please give these default values so we can test your program using just one command-line argument. Describe additional arguments (if any) in a "USAGE..." help message. Your program should print a trace of the interesting events in the program. These events include when a process calls getforks, starts to eat, calls relforks, and starts to think. For each event, print a line containing a time stamp, a process id, and a string describing the event.

(Extra for additional 20 points). Your program for part (a) should allow a philosopher to start eating as long as neither neighbor is eating. Modify your program so that philosophers get to start eating in a first-come-first-served order. This means that if one philosopher has to wait to get permission to eat (because a neighbor is eating) and a second philosopher calls getforks, the second philosopher must wait, even if neither of its neighbors is eating. Hint: You might consider using tickets (like in the ticket lock algorithm in Lecture 4, Slides 23-25) to order the waiting philosophers in getforks.

4. Yet Another Dining Philosophers problem [Dining in Hell]  (40 points) adapted from "The Art of Multiprocessor Programming" by Maurice Herlihy and Nir Shavit
In Dante's Inferno, he describes a visit to Hell. In a recently discovered chapter, he encounters five people sitting at a table with a pot of stew in the middle. Although each one holds a spoon that reaches the pot, each spoon's handle is much longer than each person's arm so that no one can feed him- or herself. They are hungry and desperate. Dante then suggests, "why do not you feed one another?" The rest of the chapter is lost.
Develop an algorithm to allow these five unfortunates to feed one another. Two or more people may not feed the same person simultaneously. Your algorithm must be, well, starvation-free. Write a multithreaded program in Java or C++ to simulate the above problem using threads representing the five unfortunates and a shared concurrent object(s) to synchronize the threads so they can "feed" one another. The object(s) can be developed as a monitor (i.e., synchronized objects). Your program should print a trace of the interesting events in the program.

Implement, using monitors, the following problems from the previous homework on Semaphores. You are not allowed to use semaphores in this homework.
5. The Hungry Birds Problem (20 points)
Given are n baby birds and one parent bird. The baby birds eat out of a common dish that initially contains W worms. Each baby bird repeatedly takes a worm, eats it, sleeps for a while, takes another worm, and so on. When the dish is empty, the baby bird who discovers the empty dish chirps loudly to awaken the parent bird. The parent bird flies off, gathers W more worms, puts them in the dish, and then waits for the dish to be empty again. This pattern repeats forever.

Represent the birds as concurrent processes (i.e., an array of "baby bird" processes and a "parent bird" process) and the dish as a concurrent object (a monitor) that can be accessed by at most one bird at a time. 

Develop a monitor (with condition variables) to synchronize the actions of the birds, i.e., develop a monitor that represents the dish. Define the monitor's operations and their implementation. Implement a multithreaded application in Java or C++ to simulate the actions of the birds represented as concurrent threads and the dish represented as the developed monitor. Is your solution fair? Explain in comments in the source code.

6. The Bear and the Honeybees Problem (20 points)
Given are n honeybees and a hungry bear. They share a pot of honey. The pot is initially empty; its capacity is H portions of honey. The bear sleeps until the pot is full, eats all the honey, and goes back to sleep. Each bee repeatedly gathers one portion of honey and puts it in the pot; the bee who fills the pot awakens the bear.

Represent the bear and honeybees as concurrent processes or threads (i.e., a "bear" process and an array of "honeybee" processes) and the honey pot as a critical resource (a monitor) that can be accessed by at most one process at a time (either by the "bear" process or by one of the "honeybee" processes). 

Develop a monitor (with condition variables) to synchronize the actions of the bear and honeybees, i.e., develop a monitor representing the pot of honey. Define the monitor's operations and their implementation. Implement a multithreaded application in Java or C++ to simulate the actions of the bear and honeybees represented as concurrent threads and the pot represented as the monitor. Is your solution fair? Explain in comments in the source code.

7. The One-Lane Bridge Problem (40 points)
Assume cars from the north, and the south arrive at a one-lane bridge. Cars heading in the same direction can cross the bridge simultaneously, but cars heading in opposite directions cannot.

Develop and implement a multithreaded program in Java or C++ to simulate the actions of the cars. Each car should be a thread that crosses the bridge trips times, first in one direction, then in the other direction, and so on. Use northCars instances of cars that first cross in a northbound direction, and use southCars instances of cars that first cross in a southbound direction. Use a monitor to control entry to the bridge. It should have operations that a car calls to ask permission to cross the bridge and to indicate that it has finished crossing the bridge. Depending on how you program the car processes, you will want to have two or four operations. (After you think about the choices, you will understand what the last sentence means!). Your solution has to ensure the required exclusion, avoid deadlocks, and ensure fairness, i.e., that any car waiting to cross the bridge eventually gets to do so.

Your program should have three command-line arguments for the values of trips, northCars, and southCars. Have the cars sleep for a random amount of time between crossings of the bridge and have them sleep for a smaller random amount of time to simulate the time it takes to cross the bridge. Stop the simulation after each car has crossed the bridge trips times. The output from your program should be a trace of significant events, such as a car wanting to cross the bridge, starting to cross, or leaving the bridge. Each output line should contain a time stamp, the car's identity associated with the event, and a short descriptive message. Write the trace to the standard output.

8. The Unisex Bathroom Problem  (40 points)
Suppose there is only one bathroom in a building. Any number of men or women can use it, but not simultaneously.
Develop a monitor to synchronize the use of the bathroom. The monitor has four public procedures: manEnter, manExit, womanEnter, and womanExit. A man process calls manEnter to get permission to use the bathroom and calls manExit when finished. A woman process calls womanEnter and womanExit. Use the Signal and Continue signaling discipline (the default discipline). Your solution has to ensure the required exclusion and avoid deadlock, and ensure fairness, i.e., ensure that any person (man or woman) who is waiting to enter the bathroom eventually gets to do so
Implement a multithreaded application in Java or C++ to simulate the actions of the "man" and "woman" processes represented as concurrent threads and the bathroom represented as the developed monitor. The output from your program should be a trace of significant events, such as a person wanting to enter the bathroom or exiting the room. Each line of output should contain a time stamp, the identity of the person associated with the event, and a short descriptive message. Write the trace to the standard output.