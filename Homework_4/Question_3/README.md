# Question 3
3. The Dining Philosophers problem (20 points + 20 points for extra work)
Write a multithreaded program in Java or C++ to simulate the Dining Philosophers problem described in Lecture 10 (Semaphores), Slide 29. There should be at least five threads, one per philosopher, and one shared object (a monitor) for the table. The shared object (monitor) "table" should have two methods: getforks(id) and relforks(id), where id is an integer between 1 and 5. Your solution need not be fair.

Your program should have one command-line argument rounds that specifies the number of rounds of thinking and eating that each philosopher should execute. Philosophers should eat and think for random amounts of time. Your program may have additional command-line arguments, for example, to control the eating and thinking intervals and the seed for the random number generator. Please give these default values so we can test your program using just one command-line argument. Describe additional arguments (if any) in a "USAGE..." help message. Your program should print a trace of the interesting events in the program. These events include when a process calls getforks, starts to eat, calls relforks, and starts to think. For each event, print a line containing a time stamp, a process id, and a string describing the event.

(Extra for additional 20 points). Your program for part (a) should allow a philosopher to start eating as long as neither neighbor is eating. Modify your program so that philosophers get to start eating in a first-come-first-served order. This means that if one philosopher has to wait to get permission to eat (because a neighbor is eating) and a second philosopher calls getforks, the second philosopher must wait, even if neither of its neighbors is eating. Hint: You might consider using tickets (like in the ticket lock algorithm in Lecture 4, Slides 23-25) to order the waiting philosophers in getforks.