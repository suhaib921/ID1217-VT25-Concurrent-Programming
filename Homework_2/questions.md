Problems
1. Compute the Sum, Min, and Max of Matrix Elements (20 points)
The purpose of this problem is to introduce you to basic OpenMP usage:
Download, compile, and run a program matrixSum-openmp.c Download matrixSum-openmp.c. The program computes a sum of matrix elements in parallel using OpenMP. Develop and evaluate the following modified version of the program.
Extend the program so that in addition to the sum, it finds and prints a value and a position (indexes) of the maximum element of the matrix and a value and a position of the minimum element of the matrix. To check your solution, initialize elements of the matrix to random values. Use OpenMP constructs. Run the program on different numbers of processors and report the speedup (sequential execution time divided by parallel execution time) for different numbers of processors (up to at least 4) and different sizes of matrices (at least 3 different sizes). Run each program several (at least 5) times and use the median value for execution time. Try to provide reasonable explanations for your results. Measure only the parallel part of your program. Specify the number of processors used by specifying a different number of threads (set the OMP_NUM_THREADS environment variable or use a call to omp_set_num_threads(), see the OpenMP specification). To measure the execution time, use the omp_get_wtime function (see omp_get_wtimeLinks to an external site.).

2. Quicksort (20 points)
The quicksort algorithm sorts the list of numbers by first dividing the list into two sublists so that all the numbers if one sublist are smaller than all the numbers in the other sublist. This is done by selecting one number (called a pivot) against which all other numbers are compared: the numbers which are less than the pivot are placed in one sublist, and the numbers which more than the pivot are placed in another sublist. The pivot can be either placed in one sublist or withheld and placed in its final position.

Develop a parallel multithreaded program (in C/C++ using OpenMP tasks) with recursive parallelism that implements the quicksort algorithm for sorting an array of n values.

Run the program on different numbers of processors and report the speedup (sequential execution time divided by parallel execution time) for different numbers of processors (up to at least 4) and different workloads (at least 3 different lists of various sizes). Run each program several (at least 5)  times and use the median value for execution time. Try to provide reasonable explanations for your results. Measure only the parallel part of your program. Specify the number of processors used by specifying a different number of threads (set the OMP_NUM_THREADS environment variable or use a call to omp_set_num_threads(), see the OpenMP specification). To measure the execution time, use the omp_get_wtime function (see omp_get_wtimeLinks to an external site.).

3. Find Palindromes and Semordnilaps (40 points)
Develop a parallel multithreaded program (in C/C++ using OpenMP) to solve the following problem. There is an online dictionary in /usr/dict/words or /usr/share/dict/words under Linux. The file is used, in particular, by the Linux spell command and contains a few thousand words, e.g., 235886 words. You can download a smaller file called words containing 25143 words. Recall that palindromes are words or phrases that read the same forward and backward, such as "noon" or "radar," i.e., if you reverse all the letters, you get the same word or phrase. Reverse pairs or semordnilaps are words whose reverse forms are different valid words, such as "draw" and "ward". Your task is to find all palindromes and all semordnilaps in the dictionary. For example, "noon" is a palindrome; hence, its reverse is trivially in the dictionary. A word like "draw" is semordnilap and "ward" is also in the dictionary. Your parallel program should use for-loop parallelism or tasks, and the number of threads used should be a command-line argument. Do the input and output phases sequentially and the rest in parallel. Your program should write the palindromes and semordnilaps in a results file.

Run the program on different numbers of processors and report the speedup (sequential execution time divided by parallel execution time) for different numbers of processors (up to at least 4) and different workloads (at least 3 different sizes of a dictionary). Run each program several times (at least 5) and use the median value for execution time. Try to provide reasonable explanations for your results. Measure only the parallel part of your program. Specify the number of processors used by specifying a different number of threads (set the OMP_NUM_THREADS environment variable or use a call to omp_set_num_threads(), see the OpenMP specification). To measure the execution time, use the omp_get_wtime function (see omp_get_wtimeLinks to an external site.).

4. The 8-queens problem (40 points)
The 8-queens problem is concerned with placing 8 queens on a chess board in such a way that no one queen can attack another. One can attack another if both are in the same row or column or are on the same diagonal. Develop a parallel program (in C/C++ using OpenMP) to generate all 92 solutions to the 8-queens problem. [Hint: You can use tasks so that the master thread recursively generates queen placements and other tasks to check whether  placements are acceptable.]

Run the program on different numbers of processors and report the speedup (sequential execution time divided by parallel execution time) for different numbers of processors (up to at least 4). Run each program several (at least 5) times and use the median value for execution time. Try to provide reasonable explanations for your results. Measure only the parallel part of your program. Specify the number of processors used by specifying a different number of threads (set the OMP_NUM_THREADS environment variable or use a call to omp_set_num_threads(), see the OpenMP specification). To measure the execution time, use the omp_get_wtime function (see omp_get_wtimeLinks to an external site.).