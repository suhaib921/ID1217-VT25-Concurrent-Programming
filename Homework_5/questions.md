Problems
1. Distributed Pairing 1 (a client-server application) (20 points)
Assume that a class has n students numbered 1 to n and one teacher. The teacher wants to assign the students to groups of two for a project. The teacher does so by having every student submit a request for a partner. The teacher takes the first two requests, forms a group from those students, and lets each student know their partner. The teacher then takes the following two requests, forms a second group, and so on. If n is odd, the last student "partners" with themself.

Model the students as client processes and the teacher as a server process. Develop and implement a distributed client-server application that includes the server (teacher) and clients (students). When your application terminates, each student process should print their index (a number or a name) and the index (a number or a name) of the student's partner. You can implement your distributed application in C using the MPI library or Java using the Java socket API or Java RMI. Your application must be distributed. In comments in the program or a README file, explain your solution (algorithm) shortly. 

2. Distributed Pairing 2 (a peer-to-peer application) (20 points)
As in the previous problem, we want to assign n students numbered 1 to n to groups of two for a project. However, the teacher does not want to be involved in forming the groups. Instead, he asks the students to interact with each other to pair up into groups. In particular, the students must devise a single algorithm every student executes. Develop a distributed pairing algorithm for the students. An ideal solution will use only n messages. The algorithm should use random numbers so that the outcome is non-deterministic. The teacher starts the algorithm by picking one student randomly and sending a message to that student saying, in effect, "your turn to pick a partner." 

Model the students and the teachers as distributed processes. Develop and implement a distributed peer-to-peer application that includes the teacher peer and several student peers executing the distributed pairing algorithm you have developed. When your application terminates, each student process should print their index (a number or a name) and the index (a number or a name) of the student's partner. You can implement your distributed application in C using the MPI library or in Java using the socket API or Java RMI. Your application must be distributed. In comments in the program or a README file, explain your solution (algorithm) shortly. 

3. Dining philosophers (20 points)
Develop a distributed application that simulates the dining philosophers. You can implement your distributed application in C using the MPI library or in Java using the socket API or Java RMI. Your program should have five philosopher processes and one server process that represents/manages the table. Simulate eating and thinking by having a philosopher sleep for a random time. Your program should print a trace of the interesting events as they happen. Your application must be distributed. In comments in the program or a README file, explain your solution (algorithm) shortly. 

4. Determine all common values in three arrays. A.k.a. The Welfare Crook problem (by Prof. D. Gries) (40 points)
Assume there are three distributed processes: F, G, and H, each having a local array of strings (or integers): f[1:n], g[1:n], and h[1:n], respectively. Assume that the first array f[1:n] is a list that contains names (or personal numbers) of people working at IBM Yorktown,  the second g[1:n] is a list of students at Columbia, and the third h[1:n] is a list of people on welfare in New York City. Assume that there is at least one person whose name is on all three lists. [ One can think that something peculiar is going on if the person's name is on all three lists! ].

Develop and implement a distributed program in which all three processes interact with each other until each process has determined all names, each of which is on all three lists. Each process prints the common names that it has determined. Use message passing (or RMI) for interaction between the processes; do not use shared variables. Messages may contain only one value at a time and (if needed) process ids. Do not send entire arrays in messages (or RMI calls) because the arrays can be huge. You can implement your distributed application in C using the MPI library or in Java using the socket API or Java RMI. In comments in the program or a README file, explain your solution (algorithm) shortly. 

5. The Stable Marriage Problem (40 points)
Let Man[1:n] and Woman[1:n] arrays of processes. Each man ranks the women from 1 to n, and each woman ranks the men from 1 to n. (A ranking is a permutation of integers from 1 to n). A pairing is a one-to-one correspondence between men and women. A pairing is stable if, for two men, Man[i] and   Man[j], and their paired women, Woman[p] and  Woman[q], both of the following conditions are satisfied:

Man[i] ranks Woman[p] higher than Woman[q], or Woman[q] ranks Man[j] higher than Man[i]; and
Man[j] ranks Woman[q] higher than Woman[p], or Woman[p] ranks Man[i] higher than Man[j].
A solution to the stable marriage problem is a set of n pairings, all of which are stable.

Assume that the processes are distributed and can interact by message passing. Develop a distributed peer-to-peer application to solve the stable marriage problem. The men should propose, and the women should listen. A woman has to accept the first proposal she gets because a better one might not come along; however, she can dump (leave) the first man if she later gets a better proposal. [Hint: To terminate, the program needs to count the number of women that have ever accepted a proposal. This could be achieved with an extra counter process or a global variable.] You can implement your distributed application in C using the MPI library or in Java using the socket API or Java RMI. Your program should print a trace of the interesting events as they happen, but do not make the trace too verbose.

6. Exchanging Values (40 points)
Consider the three program outlines (algorithms) in Lecture 15, slides 28-34, for exchanging values by interactive peers. Implement each algorithm in C using the MPI library or in Java using the socket API or Java RMI. You may use collective communication (or multicast in Java) where appropriate. Each program should execute a sequence of R rounds of exchanges. Your program should print a trace of the interesting events as they happen, but do not make the trace too verbose. Estimate and compare the performance of your programs. Build a plot that shows the total execution time of each program as a function of the number of processes (2, 4, 6, 8) and the number of rounds (1, 2, 3). When performing evaluation experiments, do not print a trace of events.